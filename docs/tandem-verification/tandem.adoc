== Tandem-based verification
:toc:

This document describes the OpenHW Group functional verification environment based on lockstep ("tandem") simulation of a RISC-V reference model and an RTL implementation of a RISC-V core.

It discusses the principle, the architecture and the usage of the environment, and outlines future work.  It also provides a reference of the programming interfaces to support hardware designers, software developers, and verification engineers.

=== Scope of verification

The verification is performed on the CVA6 core, with the exclusion of interrupt controllers, platform-related mechanisms (real-time timer), peripherals etc.

The behaviors that are verified are:

* instruction completion
* general-purpose register value changes
* CSR value changes
* memory operations (as seen by the CVA6 core)
* raising of exceptions
* raising of interrupts
* trap entry and return

=== Basic Architecture and Design Choices

==== High-level view

Tandem-based functional verification of an RTL design consists in a lockstep comparison of the behavior of an RTL implementation against the behavior of a reference model (usually an Instruction Set Simulator, or ISS), both executing the same programs from the same initial state.  In opposition to post-execution trace comparison, the tandem approach enables immediate detection of differences in observable behavior of the RTL implementation and the reference model, thus greatly simplifying the investigation of the root causes of any discrepancies.

The OpenHW Group tandem verification environment relies on the use of RVFI (RISC-V Formal Interface, https://github.com/SymbioticEDA/riscv-formal/blob/master/docs/rvfi.md).  RVFI provides a well-defined abstraction of design state at each instruction commit or exception occurrence.

RVFI events are collected from both RTL and reference model side, and a scoreboard is used to compare the states of both simulations at every step.

The reference model is a slave to the RTL model; it performs an execution step only when the RTL model has completed the current step.  This enables partial verification of behaviors involving values that depend on micro-architecture features, e.g., clock cycle counts.  The RTL provides the actual values of the registers to the reference model; these values are "trusted" by the reference model and hence, the reads of CSR registers yield the same results in the reference model as they do in the RTL simulation.

The RTL simulation environment provides the testbench and the required abstractions of platform-level resources and behaviors.  The core-level interrupt controller (CLIC) is **not** modeled; instead, interrupt management is performed by the testbench.  The RTL core model receives interrupt notifications from the testbench through the available interrupt input ports.  When the RTL model of the core detects an interrupt, the information about the interrupt is passed to the reference model by setting the `mip` (Machine Interrupt Pending) CSR to the same value as in the RTL model.

Since out-of-core behaviors (platform CSRs, interrupt control) are out of the scope of verification, the reference model includes only the core and an abstraction of the memories. In particular, CLIC/PLIC interrupt controllers are explicitly disabled and platform CSRs are not maintained.

In order to ease the integration with RTL simulators, the tandem infrastructure uses a limited subset of UVM to provide a uniform SystemVerilog interface across all RTL simulators, whether commercial or open-source.

TODO Add figure of overall structure

==== Operation

The execution of the tandem simulation is controlled by the main RTL simulation loop that is managed either by the "run" phase of the UVM testbench, or explicitly in a test harness.  The RTL simulation runs through successive clock cycles until reaching an instruction commit or an exception in the current cycle.  The RVFI interface is then queried to fill the RTL-side entries of the scoreboard with current general-purpose and CSR register state.

Volatile state information (interrupt status, values of selected CSRs which are driven by the microarchitecture) is injected into the reference model.  The reference model then executes as many instructions as were committed in the current RTL cycle.  If an exception is detected in the RTL model, the reference model is expected to detect the same exception.

TODO what happens if in superscalar mode the second instruction triggers an exception (both insns are cancelled? First insn gets committed?)

If a discrepancy in RFVI state is detected by the scoreboard, an appropriate human-readable error output is generated and the error count of the simulation is incremented.  The tandem simulation stops once a preset number of errors is encountered.  By controlling the erro limit is it possible to accommodate transient differences between the RTL and reference model states.  A typical example of transient difference occurs when two instructions are committed in a single cycle by a superscalar RTL implementation, causing the counter of retired instructions `minstret` to be atomically incremented by two whereas the reference model will always commit instruction one by one, thus incrementing `minstret` by one each time.

TODO Add timing diagram of the basic operation cycle

==== Implementation

The RTL testbenches use DPI functions to control Spike stepping, inject CSR values and query Spike's RVFI interface upon "RVFI valid" events.

To limit the impact on the upstream code base, Spike modifications rely on "shim" (adapter) classes that add extra functionality in two ways:

* by adding a new base class below the original base class (used for CSRs)
* by specializing a class to provide additional interfaces (Processor and Simulation)

The Spike execution model was modified to run a single-instruction step function instead of the performance-optimized "instruction batch" mode that executes hundreds to thousands of instructions without yielding the control to the environment of the simulated design.

In order to provide fine-grained control over the configuration of the simulated design, Spike was extended with a parameter mechanism with the following characteristics:

* four additional ways of controlling Spike simulator behavior:
** configuration files (Yaml)
** DPI API
** C++ API
** additional command-line arguments
* ability to set platform-related values (memory map, boot addresses)
* ability to set implementation-defined values (number of PMP regions in total, vnedor ID, architecture ID, implementation ID, ...)
* extended CSR control:
** availability of any CSR
** initialization masks and values
** write-enable masks with single bit granularity
* ability to inject CSR values from the RTL model for architecture-dependent CSRs (`cycles`/`cyclesh`, `mcycles`/`mcyclesh`, `mip` etc.)

=== Fundamental limitations of the tandem verification approach

* By definition, a reference model based on an instruction set simulator has only the notion of instruction commits and is not capable of representing the behaviors between commits (transient signals, micro-architectural artefacts such as stalls etc.)
+
Such behaviors must be verified by other means.

* Simultaneous occurrence of the same error in both reference model and RTL implementation will not be detected since the two behaviors will match.
+
This stresses the importance of validation of the reference model against the specification.

* Since the reference model for tandem verification does not include an interrupt controller, the presence of pending interrupts must be notified to the `mip` register by other means.
+
In the OpenHW Group solution, the presence of the interrupt is detected by the RTL model and the information about the actual interrupt raised as the result of interrupt arbitration is passed to the reference model in the `mcause` register.  The value in `mcause` is then used to trigger the corresponding event in the reference model.

* Transient discrepancies can be caused by differences between purely sequential and concurrent model execution.
+
Spike executes instructions in sequence whereas a superscalar architecture may commit multiple instructions in a single cycle; this means that some CSR updates may differ between Spike and RTL, typically MINSTRET may advance by 2 or more in the RTL model, yet Spike will increment it by 1 at every instruction committed.

=== QuickStart Guide

==== Build instructions

The standard build procedure of Spike supplied with the CVA6 project (https://github.com/openhwgroup/cva6/) builds a Spike binary with all necessary modifications required for DPI interfacing to the RTL testbench.

Building Spike with tandem extensions requires the availability of `CMake` in version 3.16 or higher.  The `yaml-cpp` source package (https://github.com/jbeder/yaml-cpp) that is used to parse and manipulate Yaml configurations is a submodule of Spike and will be downloaded when performing a recursive clone or update of the CVA6 repository.

If a rebuild is required in an existing setup, it is necessary to either select a different installation directory for Spike or to remove the current installation directory.  It is also necessary to remove Spike build directories `verif/core-v-verif/vendor/riscv/riscv-isa-sim/build` (Spike proper) and `verif/core-v-verif/vendor/riscv/riscv-isa-sim/yaml-cpp/build` (`yaml-cpp` library).

==== Understanding the Spike configuration file

Spike configuration files represent a Spike parameter tree in the form of nested Yaml dictionaries under a common root node `spike_param_tree`:

[,yaml]
----
  spike_param_tree:
    bootrom: true
    bootrom_base: 65536
    bootrom_size: 4096
    dram: true
    dram_base: 2147483648
    dram_size: 1073741824
    generic_core_config: false
    isa: rv32imczicsr_zcb_zba_zbb_zbc_zbs
    priv: M
    core_configs:
      -
        isa: rv32imczicsr_zcb_zba_zbb_zbc_zbs
        extensions: cv32a60x,cvxif
        boot_addr: 2147483648
        marchid_override_mask: 0xFFFFFFFF
        marchid_override_value: 0x3
        misa_write_mask: 0x0
----

==== Running simulations in tandem mode

Tandem verification is enabled by setting environment variable `SPIKE_TANDEM` to a non-empty value prior to invoking any of the test scripts located in the `verif/regress` directory of the CVA6 source tree.

**Example:**
[,sh]
----
export SPIKE_TANDEM=1 ; bash verif/regress/dv-csr-embedded-tests.sh
----

Currently, tandem simulations are supported out-of-the-box for RTL simulator configurations `vcs-uvm` (recommended), `vcs-testharness`, `questa-uvm` and `questa-testharness`.  Tandem simulations with Verilator using the `veri-testharness` configuration require the availability of Verilator v5.016 or higher.

=== How to analyze tandem verification results

To simplify failure analysis, the tandem scoreboard reports any discrepancies between commit states of the reference model and the RTL model but produces no output if the commit states are identical.

A failure is represented by a pair of TODO


=== Recipe book

1. Enable (make "accessible") or disable (make "inaccessible") a CSR
+
A Boolean parameter consisting of CSR name and suffix `_accessible`, placed in generic or per-core configuration, indicates whether the given register should be accessible or not.
+
**Example**:
+
[,yaml]
----
   tinfo_accessible: False
----
+
makes the `tinfo` CSR inaccessible for Spike, which in turn will trigger an illegal instruction exception upon accessing `tinfo`.

1. Make modifiable or constant specific bits in a CSR
1. Add a new parameter to Spike

=== Integration with the RISC-V Open Source ecosystem

* The entire tandem verification infrastructure is available as Open Source under SHL 2.0+ (an Apache-type license) in OpenHW Group repositories `cva6` (https://github.com/openhwgroup/cva6/) and `core-v-verif` (https://github.com/openhwgroup/cva6/).

* The OpenHW Group tandem verification infrastructure relies on Spike (https://github.com/riscv-software-src/riscv-isa-sim/) as reference model.
+
The tandem verification approach is a general template and is not bound to a single ISS or RTL simulator.  However, it requires that the ISS provides a basic platform capable of running software matching the capabilities of the RTL testbench, including a model of memory and buses.
Because of this constraint the current tandem framework relies on Spike which is fully Open Source and provides all necessary components.

* Verilator-based tandem
+
Starting with version 5.016, Verilator supports tandem simulations.  Earlier versions did not provide sufficient support for structrured types in DPI interface.

=== Integration with other EU Projects

In order to support a full specification-to-implementation Open Source path for RISC-V, there is an activity in the ISOLDE project (https://www.isolde-project.eu/content/over-project) aiming at the automatic generation of Spike Yaml configuration files from pre-validated RISC-V configurations produced by the `riscv-config` tool (https://github.com/riscv-software-src/riscv-config).

=== Future work

* multi-core simulations
** per-core configurations
** integration with complex platform models
* alternative reference models
** advent of Sail

include::reference.adoc[]
