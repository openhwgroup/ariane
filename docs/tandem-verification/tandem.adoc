== Tandem-based verification
:toc:

This section describes the OHG functional verification environment based on lockstep ("tandem") simulation of a RISC-V reference model and an RTL implementation of a RISC-V core.

It discusses the principle, the architecture and the usage of the environment, and outlines future work.

=== Scope of verification

The verification is applied the CVA6 core, with the exclusion of interrupt controllers, platform-related mechanisms (real-time timer), peripherals etc.

The behaviors that are verified are:

* instruction completion
* general-purpose register value changes
* CSR value changes
* memory operations (as seen by the CVA6 core)
* raising of exceptions
* raising of interrupts
* trap entry and return

=== Basic Architecture and Design Choices

==== High-level requirements

Use RVFI (https://github.com/SymbioticEDA/riscv-formal/blob/master/docs/rvfi.md); events are collected from ISS and RTL side and a scoreboard is used to compare the state.  RVFI is based on commit/exception state.

RTL simulation environment provides the testbench and the required abstractions of platform-level resources and behaviors.  The core-level interrupt controller (CLIC) is **not** modeled; instead, interrupt management is performed by the testbench.  The RTL core model receives interrupt notifications from the testbench through the available interrupt input ports.

The reference model is a slave to the RTL model.

Since out-of-core behaviors (platform CSRs, interrupt control) are out of the scope of verification, the reference model (Spike) includes only the core; CLIC/PLIC interrupt controllers are explicitly disabled and platform CSRs are not maintained.

Use basic UVM infrastructure to provide uniform SYstemVerilog interface for all simulators, whether commercial or open-source.

TODO Add figure of overall structure

==== Operation

The RTL simulation runs through successive clock cycles until reaching an instruction commit or an exception in the current cycle.  The scoreboard stores the current general-purpose and CSR register state.

Volatile state information (interrupt status, values of selected CSRs which are driven by the microarchitecture) is injected into the reference model which then executes as many instructions as were committed in the current RTL cycle.  If an exception is detected in the RTL model, the reference model is expected to detect the same exception.
TODO what happens if in superscalar mode the second instruction triggers an exception (both insns are cancelled? First insn gets committed?)

TODO Add timing diagram of the basic operation cycle

==== Implementation

The RTL testbenches use DPI functions to control Spike stepping, inject CSR values and query Spike's RVFI interface upon "RVFI valid" events.
TODO where is the hook to call Spike 'step()' function?

To limit the impact on the upstream code base, Spike modifications rely on "shim" (adapter) classes that add extra functionality in two ways:
* by adding a new base class below the original base class (used for CSRs)
* by specializing a class to provide additional interfaces (Processor and Simulation)

Spike was modified to run a single-instruction step function instead of "insn batch" mode.

Spike is **an implementation** of RISC-V (has its own archid value assigned), so in order to support multiple configurations it was extended with a parameter mechanism:

* three ways of control: command-line, configuration files (Yaml) and API
* scope of CSR control:
** availability of CSR
** initialization mask+values
** write-enable masks with bit granularity
* CSR injection for architecture-dependent CSRs (mcycles etc.)

Parameters are organized into a tree (hierarchical directory) structure so that related parameters can be designated using a common prefix.

=== Fundamental limitations

* Spike has only the notion of instruction commits, so it is not capable of representing the behaviors between commits (transient signals, micro-architectural artefacts such as stalls etc.) Such behaviors must be verified by other means.
* interrupt presence and the results of interrupt arbitration are passed to Spike (there are no input signals in 
* same error in both reference model and RTL implementation will not be detected since the two behaviors will match
* purely sequential vs. concurrent events: Spike executes instructions in sequence whereas a superscalar architecture may commit multiple instructions in a single cycle; this means that some CSR updates may differ between Spike and RTL, typically MINSTRET may advance by 2+ in RTL but Spike will increment it by 1 at every instruction committed.

=== QuickStart Guide

* build instructions:
+
  Spike extensions are built by default when rebuilding the vendorized Spike delivered as part of the `core-v-verif` tree.
* understanding the Spike configuration file
+
  Spike configuration files provide represent a Spike parameter tree in the form of nested Yaml dictionaries under a common root node `spike_param_tree`:
+
[,yaml]
----
  spike_param_tree:
    bootrom: true
    bootrom_base: 65536
    bootrom_size: 4096
    dram: true
    dram_base: 2147483648
    dram_size: 1073741824
    generic_core_config: false
    isa: rv32imczicsr_zcb_zba_zbb_zbc_zbs
    priv: M
    core_configs:
      -
        isa: rv32imczicsr_zcb_zba_zbb_zbc_zbs
        extensions: cv32a60x,cvxif
        boot_addr: 2147483648
        marchid_override_mask: 0xFFFFFFFF
        marchid_override_value: 0x3
        misa_write_mask: 0x0
----

* SPIKE_TANDEM variable
+
  Tandem verification is enabled by setting environment variable `SPIKE_TANDEM` to a non-empty value.

* obtaining the list of all available parameters

=== How to analyze tandem verification results

To simplify failure analysis, the tandem scoreboard reports any discrepancies between commit states of the reference model and the RTL model but produces no output if the commit states are identical.

A failure is represented by a pair of TODO


=== Recipe book

1. Enable (make "accessible") or disable (make "inaccessible") a CSR
+
   A Boolean parameter consisting of CSR name and suffix `_accessible`, placed in generic or per-core configuration, indicates whether the given register should be accessible or not.
+
   **Example**:
+
[,yaml]
----
   tinfo_accessible: False
----
   makes the `tinfo` CSR inaccessible for Spike, which in turn will trigger an illegal instruction exception upon accessing `tinfo`.

1. Make modifiable or constant specific bits in a CSR
1. Add a new parameter to Spike

=== Integration with the RISC-V Open Source ecosystem

* infrastructure available as Open Source (under SHL 2.0+, an Apache-type license)
* use of Spike as reference model
+
  The tandem verification approach is a general template and is not bound to a single ISS or RTL simulator.  However, it requires that the ISS provides a basic platform capable of running software matching the capabilities of the RTL testbench, including a model of memory and busses.
  Because of this constraint the current tandem framework relies on Spike which is fully Open Source and provides all necessary components.
* Verilator-based tandem
+
  Starting with version 5.016, Verilator supports tandem simulations.  Earlier versions did not provide sufficient support for structrured types in DPI interface.
* `riscv_config` and the generation of configuration files
+
  The `riscv-config` utility provides a formalized way of capturing ISA and CSR specifications of RISC-V implementations.
  Scripts developed in the CVA6 projects post-process validated `riscv-config` output and generate a Spike parameter tree corresponding to the configuration described in `riscv-confg` source.
  The scripts and their output are published in the CVA6 repository under `config/gen_from_riscv_config`.

=== Future work

* multi-core simulations
** per-core configurations
** integration with complex platform models
* alternative reference models
** advent of Sail

include::reference.adoc
